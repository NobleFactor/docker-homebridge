#!/usr/bin/env bash

########################################################################################################################
# Licensed under the MIT License - see LICENSE file for details.
# Copyright (c) 2025 Noble Factor. All rights reserved.
# Declare-BashScript - Provides argument parsing and utility functions for bash scripts.
########################################################################################################################

# Source this file as follows: 
#   source Declare-BashScript <script_path> <long-options> <short-options>
# Example: 
#   source Declare-BashScript $0 "help,verbose,path:," "hvp" "$@"

set -o errexit -o nounset -o pipefail

###########
# Variables
###########

declare -r script_root="$(cd "$(dirname "$1")" && pwd)"
declare -r script_name="$(basename "$1")"
declare -r script_long_options="${2:-}"
declare -r script_options="${3:-}"

shift 3 || shift 2 || shift 1 ;# Shift past the first three arguments to leave only the options for parsing

###########
# Functions
###########

function usage {
    local _synopsis="${1:-}"

    # Require a synopsis so callers can provide a fallback when man is unavailable
    if [[ -z "$_synopsis" ]]; then
        printf '[%s][ERROR] \033[31m%s\033[0m usage() requires a synopsis argument.\n' "$script_name" "$Heavy_ballot" >&2
        exit 2
    fi

    # Prefer system man if available
    if man -w "${script_name}" >/dev/null 2>&1; then
        man "${script_name}"
        exit 0
    fi

    # Fallback to a script-relative man path if present
    if man -M "${script_root}/man" -w "${script_name}" >/dev/null 2>&1; then
        man -M "${script_root}/man" "${script_name}"
        exit 0
    fi

    # Final fallback: print the synopsis provided by the caller
    printf "%s\n" "$_synopsis"
    exit 0
}

function error {
    local rc=$1
    shift 1
    printf '[%s][ERROR] \033[31m%s\033[0m %s\n' "$script_name" "$Heavy_ballot" "$@" >&2
    if (( $rc != 0 )); then
        exit $rc
    fi
}

function note {
    printf "[%s][NOTE] %s\n" "$script_name" "$@" >&2
}

function success {
    printf '[%s][SUCCESS] \033[32m%s\033[0m %s\n' "$script_name" "$Heavy_check_mark" "$@" >&2
}

###########
# Constants
###########

# useful for printing text to console...

declare -r b="$(tput bold)"  ; # bold
declare -r n="$(tput sgr0)"  ; # normal
declare -r u="$(tput smul)"  ; # underline
declare -r u_="$(tput rmul)" ; # underline off (neither $n nor $b defeat $u)

declare -r Heavy_ballot='✘'
declare -r Heavy_check_mark='✔'

###########
# Arguments
###########

declare -r script_arguments=$(getopt -n "${script_name}" -o "$script_options" --long "$script_long_options" -- "$@")

if [ $? -ne 0 ]; then
    error 1 "Unable to parse arguments: $arguments"
fi
